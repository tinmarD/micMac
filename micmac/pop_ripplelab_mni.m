function [VI, ALLWIN, ALLSIG] = pop_ripplelab_mni (VI, ALLWIN, ALLSIG)
% [VI, ALLWIN, ALLSIG] = POP_RIPPLELAB_MNI (VI, ALLWIN, ALLSIG)
% Interfaces the MNI HFO detector implemented in RIPPLELAB
% Navarrete M, Alvarado-Rojas C, Le Van Quyen M, Valderrama M (2016) 

[SigCont,~,~,~,sigdesc] = getsignal (ALLSIG,'type','continuous');

if isempty(SigCont)
    dispinfo('No signal loaded');
    return;
end
[fLowStr,fHighStr] = getcutofffreqfromsigdesc(SigCont(end).desc);

cb_sigselchanged = [   
    '[~,~,~,~,sigdesc] = getsignal (ALLSIG,''type'',''continuous'');',...
    'selnum     = get(findobj(''parent'',gcbf,''tag'',''allsigs''), ''value'');',...
    'selsigdesc = sigdesc{selnum};',...
    '[fLow,fHigh] = getcutofffreqfromsigdesc(selsigdesc);',...
    'set(findobj(''parent'',gcbf,''tag'',''lowcutofffreq''),''string'',fLow);',...
    'set(findobj(''parent'',gcbf,''tag'',''highcutofffreq''),''string'',fHigh);',...    
];

cb_chansel = [
    'chanselpos = get(gcbf,''userdata'');',...
    'sigdesc    = get(findobj(gcbf, ''tag'', ''allsigs''),''String'');',...
    'pos        = get(findobj(gcbf, ''tag'', ''allsigs''),''Value'');',...
    '[~,sigpos] = getsigfromdesc (ALLSIG, sigdesc{pos});',...
    'chanselpos = pop_channelselect(ALLSIG(sigpos),1,1,chanselpos);',...
    'set(gcbf,''userdata'',chanselpos);',...
    ];



geometry = {[1,1],[1,1],1,[1,1],[1,1],1,[1,1],[1,1],[1,1],[1,1],[1,1],1,1,[1,1],[1,1],[1,1],[1,1],[1],[1,3,1]};
uilist   = {...
    {'Style','text','String','Filtered Signal :'},...
    {'Style','popupmenu','String',sigdesc,'tag','allsigs','value',length(SigCont),'callback',cb_sigselchanged},...
    {'Style','text','String','Events name :'},...
    {'Style','edit','String','hfo-mni'},...
    {},...
    {'Style','text','String','Low cut-off freq (Hz) :'},...     % 3
    {'Style','edit','String',fLowStr,'tag','lowcutofffreq'},...
    {'Style','text','String','High cut-off freq (Hz) :'},... 
    {'Style','edit','String',fHighStr,'tag','highcutofffreq'},...
    {},...
    {'Style','text','String','Min Window Time (s) :'},...   % 5 
    {'Style','edit','String','0.010'},...
    {'Style','text','String','CHF epoch (s):'},...
    {'Style','edit','String','60'},...
    {'Style','text','String','Min gap Time (s) :' },...
    {'Style','edit','String','0.010'},...
    {'Style','text','String','CHF percentil (%) :'},...
    {'Style','edit','String','95'},...
    {'Style','text','String','Threshold percentil (%) :'},...
    {'Style','edit','String','99.999'},...
    {},...    
    {'Style','text','String','Baseline parameters'},... % 10
    {'Style','text','String','Segments (s):'},...
    {'Style','edit','String','0.125'},...
    {'Style','text','String','Shift :'},...
    {'Style','edit','String','0.5'},...
    {'Style','text','String','Threshold :'},...
    {'Style','edit','String','0.67'},...
    {'Style','text','String','min Baseline (Sec/min):'},...
    {'Style','edit','String','5'},...
    {},...
    {},{'Style','pushbutton','String','Channel Selection','Callback',cb_chansel},{},...
};

[results, chanselpos] = inputgui (geometry, uilist, 'title', 'RIPPLELAB - MNI Detector');

if ~isempty(results)
    dispinfo('RIPPLELAB - MNI Detector ...',1);
    
    Sig                     = SigCont(results{1});
    sigid                   = Sig.id;
    %- Freqs
    params.lowFreq          = str2double(results{3});
    if isempty(params.lowFreq);
        warning('Signal does not seem to be high-pass filtered');
        params.lowFreq=5; 
    end
    params.highFreq         = str2double(results{4});
    if isempty(params.highFreq); params.highFreq=Sig.srate/2.1; end;
    %- Other params
    params.minWinTime       = str2double(results{5});
    params.CHFepoch         = str2double(results{6});
    params.minGapTimeSec    = str2double(results{7});
    params.CHFPercentil     = str2double(results{8});
    params.threshPercentil  = str2double(results{9});
    %- Baseline
    params.segmentSec       = str2double(results{10});
    params.shift            = str2double(results{11});
    params.threshold        = str2double(results{12});
    params.minBaseline    	= str2double(results{13});

    eventType       = results{2};
    
    % TODO Check validity of inputs
    
    %- Check input signal is low-pass filtered
    if isempty(getcutofffreqfromsigdesc(Sig.desc))
        answer = questdlg(['Warning: input signal ',Sig.desc,' should be filtered ',...
            'to remove at least low frequencies. Continue ?']);
        if ~strcmp(answer,'Yes')
            dispinfo('',0);
            return;
        end
    end
    
    % Launch detector on each eeg channel
    x = Sig.data;
    if isempty(chanselpos)
        chanselpos  = nonzeros(Sig.eegchannelind.*(1:Sig.nchan));
        %- Remove bad channels
        chanselpos(ismember(chanselpos,Sig.badchannelpos))=[];
    end    
    
    h_wb = waitbar(0,'RIPPLELAB - MNI Detector','color',vi_graphics('waitbarbackcolor'),'visible','off','name','micMac');
    set(get(findobj(h_wb,'type','axes'),'title'),'color',vi_graphics('textcolor')); set(h_wb,'visible','on');
    
    for i=1:length(chanselpos)
        %- HFO detection
        HFOEvents = ripplelab_findHFOxMNI(x(chanselpos(i),:),params,Sig.srate);
        if ~isempty(HFOEvents)
            tstarts = (HFOEvents(:,1)-1)/Sig.srate;
            tends   = (HFOEvents(:,2)-1)/Sig.srate;
            tends   = min(tends,Sig.tmax);
            for j=1:length(tstarts)
                 VI = addeventt(VI, ALLWIN, ALLSIG, eventType, tstarts(j), tends(j)-tstarts(j), chanselpos(i), sigid);
            end
        end
        try waitbar(i/length(chanselpos),h_wb); catch; end;
    end
    try close(h_wb); catch; end;
    
    dispinfo('');    
    [VI, ALLWIN, ALLSIG] = pop_seeevents(VI, ALLWIN, ALLSIG);
    
end

end